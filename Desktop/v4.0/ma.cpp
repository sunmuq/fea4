/****************************************************************************
** Generated by HaiQ
**
** Project name:  fbblock
** Project date:  Tue Nov 16 2010
****************************************************************************/

// Version 16. 2018



#include <QApplication>
#include <QWidget>
#include <QDebug>
#include "fbtimer.h"

#include "arrays.h"
#include <math.h>
#include "mda_io.h"

#include <QFileInfo>
#include <QTime>
#include <QFile>

#include "fbblocksolver.h"
#include "fbblock.h"
#include "fbparameterfile.h"

#include <unistd.h>




// -----------------------------------------------------------------------
void usage() {printf("Usage: fbblock [bvf_map_file] [parameter file]\n");}


// -----------------------------------------------------------------------
void show_bvfmap(const FBArray3D<unsigned char>& bmp, const string msg="")
 {
  // Print values, rarefied
  const long NN1 = bmp.N1(), NN2 = bmp.N2(), NN3 = bmp.N3();
  
  cout << "\n";
  cout << msg << endl;
  printf("BVF map's dimensions = (%5ld, %5ld, %5ld)\n", NN1, NN2, NN3);
  for (int i=0; i<NN1; i += 40)
  for (int j=0; j<NN2; j += 60)
  for (int k=0; k<NN3; k += 80)
   {
    register unsigned char val = bmp.value(i, j, k);
    printf("i=%4d  j=%4d  k=%4d  value=%4d\n", 
	    i, j, k, static_cast<unsigned int>(val));
   }
  cout << endl;     
 }

 
// -----------------------------------------------------------------------
//void calculate_Tz(const _stress_map(const FBArray3D<unsigned char>& bmp, const string msg="")
// {
//  // Print values, rarefied
//  const long NN1 = bmp.N1(), NN2 = bmp.N2(), NN3 = bmp.N3();
  
//  cout << "\n";
//  cout << msg << endl;
//  printf("BVF map's dimensions = (%5ld, %5ld, %5ld)\n", NN1, NN2, NN3);
//  for (int i=0; i<NN1; i += 40)
//  for (int j=0; j<NN2; j += 60)
//  for (int k=0; k<NN3; k += 80)
//   {
//    register unsigned char val = bmp.value(i, j, k);
//    printf("i=%4d  j=%4d  k=%4d  value=%4d\n", 
//	    i, j, k, static_cast<unsigned int>(val));
//   }
//  cout << endl;     
// }


// -----------------------------------------------------------------------
void modify_bvf_map(FBArray3D<unsigned char>& bmp) 
{
  const long NN1 = bmp.N1(), NN2 = bmp.N2(), NN3 = bmp.N3();
  register float fval, coeff;
  
  for (int i=0; i<NN1; i++)
  for (int j=0; j<NN2; j++)
  for (int k=0; k<NN3; k++)
   {
    register unsigned char val = bmp.value(i, j, k);
    //coeff = 0.9 + 0.05*sin(i-j+789.6*k - 2.89*i/(i+k+j+3) + val);
    coeff = 0.90000000000;
    fval =   static_cast<float>(val)  *  coeff;
    val =    static_cast<unsigned char>(nearbyintf(fval)); // Modified value
    //if(ldiv(i, 10).rem == 0  &&  j == k  &&  ldiv(j, 90).rem == 0) // Rarefying
    //  printf("Modified val = %3d\n", static_cast<unsigned int>(val));

    bmp.setValue(val, i, j, k);
   }
}

 


 




//-------------------------------------------------------------------------
int ma(int argc, char *argv[])
{
QCoreApplication app(argc, argv);

FBTimer::startTimer("total");

// Determine the input file names (bvf map and parameters files)
QString bvfmap_fname;
QString param_fname;
QString base_fname;


int tcounter;                  // Current compression test counter. Starts from 1.
const int NUM_TESTS = 10;




{
 for (int i=1; i<argc; i++) 
 {
   QString param=argv[i];
   if (QFileInfo(param).suffix()=="mda")      { bvfmap_fname=param; }  
   else if (QFileInfo(param).suffix()=="fes") { param_fname=param;  }
 }

base_fname=QFileInfo(bvfmap_fname).path()+"/"+QFileInfo(bvfmap_fname).baseName();

#ifdef WIN32
bvfmap_fname.replace("/","\\");
param_fname.replace("/","\\");
base_fname.replace("/","\\");
#endif
}


// Check to make sure these are non-empty
if ((bvfmap_fname.isEmpty())||(param_fname.isEmpty())) 
{
 usage(); // Print usage information
 return -1;
}


// Initialize the solver with the BVF map, and clear the bvfmap to save memory

FBArray3D<unsigned char> bvfmap;


FBTimer::startTimer("set_bvf");
FBBlockSolver Solver;
//Solver.setEpsilon(0.13F);
cout << "Private member epsilon = " << Solver.getEpsilon() << endl; 
getchar();



{
 if (!read_mda(bvfmap, bvfmap_fname)) 
  {
    printf("Error reading bvf map: %s.\n", bvfmap_fname.toAscii().data());
    return -1;
  }
 else 
  {
    printf("BVF map found: %ldx%ldx%ld\n",
	    bvfmap.N1(),bvfmap.N2(),bvfmap.N3());
    show_bvfmap(bvfmap, "BVF map as read from file:");
  }

 Solver.setBVFMap(bvfmap);
 //bvfmap.clear();
}

FBTimer::stopTimer("set_bvf");

FBTimer::startTimer("read_parameters");
// --- Read the parameters in the parameter file ---
FBParameterFile PF;
PF.read(param_fname);



// --- Resolution ---
QList<fbreal> resolution=PF.getArray("RESOLUTION"); 
if ((resolution.count()==3)&&(!resolution.contains(0))) 
 {
   printf("Setting resolution = %gx%gx%g mm^3\n",resolution[0],resolution[1],resolution[2]);
   Solver.setResolution(resolution);
 }
else { printf("Error: invalid resolution.\n"); return -1; }
	
// --- Epsilon ---
if (PF.getReal("EPSILON") > 0.0) 
 {
   printf("Setting epsilon = %g\n", PF.getReal("EPSILON"));
   Solver.setEpsilon(PF.getReal("EPSILON"));
   cout << "In ma.cpp, the set epsilon = " << Solver.getEpsilon() << endl;
   getchar();
 }

// --- Max. iterations ---
                  //if (PF.getInteger("MAX ITERATIONS")>0) {
printf("Setting max iterations = %d\n",PF.getInteger("MAX ITERATIONS"));
Solver.setMaxIterations(PF.getInteger("MAX ITERATIONS"));
                  //}
	
// --- Number of threads ---
if (PF.getInteger("NUM THREADS") > 0) 
 {
   printf("Setting num threads = %d\n",PF.getInteger("NUM THREADS"));
   Solver.setNumThreads(PF.getInteger("NUM THREADS"));
  }

// --- Use of preconditioner ---
if (PF.getString("PRECONDITIONER")=="yes") 
 {
   printf("Compute with preconditioner..\n");
   Solver.setUsePreconditioner(true);
  }
else Solver.setUsePreconditioner(false);

// --- Setting Young's modulus and Poission ratio ---
fbreal youngs_modulus = 1,  poissons_ratio = 0.3F;
if (PF.getReal("YOUNGS MODULUS")) youngs_modulus = PF.getReal("YOUNGS MODULUS");
poissons_ratio = PF.getReal("POISSONS RATIO");	
printf("Setting Young's modulus = %g\n",youngs_modulus);
printf("Setting Poisson's ratio = %g\n",poissons_ratio);

FBTimer::stopTimer("read_parameters");



FBTimer::startTimer("computing_stiffness_matrix");
 {	
  FBArray2D <float> stiffness_matrix;
  stiffness_matrix.allocate(24, 24);
  compute_stiffness_kernel(stiffness_matrix,youngs_modulus,poissons_ratio,resolution); 
  Solver.setStiffnessMatrix(stiffness_matrix);
 }
FBMacroscopicStrain strain;
strain.eps11=strain.eps22=strain.eps33=strain.eps12=strain.eps13=strain.eps23=0.0;
for (int i=0; i<3; i++)
for (int j=0; j<3; j++)
 strain.boundaryRestrictions[i][j]=false;
FBTimer::stopTimer("computing_stiffness_matrix");




// --- Compression test ---
if (PF.getString("COMPRESSION TEST")=="yes") 
{
 QString dir=PF.getString("COMPRESSION DIRECTION");
 if      (dir=="X") { strain.boundaryRestrictions[0][0]=true; strain.eps11=1.0; }
 else if (dir=="Y") { strain.boundaryRestrictions[1][1]=true; strain.eps22=1.0; } 
 else if (dir=="Z") { strain.boundaryRestrictions[2][2]=true; strain.eps33=1.0; }
 else dir="UNDEFINED";
 
 if (PF.getString("RESTRICT ALL SURFACES")=="yes") 
  {
    printf("Restricting all surfaces...\n");
    base_fname=base_fname+"."+dir+"0";
    
    for (int i=0; i<3; i++)
    for (int j=0; j<3; j++)
      strain.boundaryRestrictions[i][j]=true;
  }
 else 
  { base_fname=base_fname+"."+dir; }	

 
 FBTimer::startTimer("set_fixed_variables");
 long num_elements = 0;		
 num_elements=Solver.setFixedVariables(strain);
 printf("Number of elements: %ld\n",num_elements);
 FBTimer::stopTimer("set_fixed_variables");

 FBTimer::startTimer("set_initial_displacements");
 Solver.setInitialDisplacements(strain);
 FBTimer::stopTimer("set_initial_displacements");

 QString initial_displacements_fname=PF.getString("INITIAL DISPLACEMENTS");
 if (!initial_displacements_fname.isEmpty()) 
  {
    FBSparseArray4D displacements0;
    if (!read_mda(displacements0, initial_displacements_fname)) 
     {
      qWarning() << "Unable to open initial displacements array:" << initial_displacements_fname;
      exit(-1);
     }

    Solver.setInitialDisplacements(displacements0);
  }

  
  
  
  
 // Anchor 10
 // Starting series with change of BVF map after every solving
 printf("===== Performing compression test in %s direction... =====\n", 
	 dir.toAscii().data());

 for(tcounter = 1;      tcounter <= NUM_TESTS;     tcounter++)
 {
  printf("\n\n\n----- Starting test # %3d (out of total %3d tests) -----\n", 
	  tcounter, NUM_TESTS);
  
  printf("===== Printing the BVF map: =====\n");
  show_bvfmap(bvfmap, "BVF map before solving:");
  //sleep(2);
  
  Solver.solve();
 
  FBTimer::startTimer("get_stress_after_solve");
  QList<double> sigma = Solver.getStress();
  FBTimer::stopTimer("get_stress_after_solve");
 
  printf("\n\n\n");
   {
    QString fname=base_fname + ".output.txt";
    QString txt;
    fbreal result=0;
    if (dir=="X")      result=sigma[0];
    else if (dir=="Y") result=sigma[1];
    else if (dir=="Z") result=sigma[2];
  
    txt += QString("Results of compression test in %1 direction:\n").arg(dir);
    txt += QString("%1\n\n").arg(result);
    txt += QString("STRESS:\n");
  
    for (int j=0; j<6; j++) txt+=QString("%1\t").arg(sigma[j]);
    txt += "\n";
    txt += "\nNUM ITERATIONS:\n";
    txt += QString("%1\n").arg(Solver.getNumIterations());
    txt += "\nNUM ELEMENTS:\n";
    txt += QString("%1\n").arg(num_elements);
    qDebug()  << txt;

    txt+="\nPARAMETERS:\n";
    QStringList paramkeys=PF.keys();
    foreach (QString paramkey,paramkeys) 
      txt+=QString("%1=%2\n").arg(paramkey).arg(PF.getString(paramkey));
		
    write_text_file(fname,txt);
   }   // End of printf

   
  if (PF.getString("DISPLACEMENT MAP")=="yes") 
   {
    FBTimer::startTimer("output_displacement_map");
    QString fname=base_fname+".displacement.mda";
    printf("Writing %s...\n",fname.toAscii().data());
    FBSparseArray4D X0;
    Solver.getDisplacements(X0);
    write_mda(X0,fname);
    FBTimer::stopTimer("output_displacement_map");
   }

   
   
   
  if (PF.getString("FORCE MAP")=="yes") 
   {
    FBTimer::startTimer("output_force_map");
    QString fname=base_fname+".force.mda";
    printf("Writing %s...\n",fname.toAscii().data());
    FBSparseArray4D X0;
    Solver.getForces(X0);
    write_mda(X0,fname);
    FBTimer::stopTimer("output_force_map");
   
    
    // ----- Printing forces, rarefied -----
  
    //cout << X0.N4() << endl;   getchar();
    for (long z=0; z<X0.N4(); z++) 
    {  
     bool to_printz, to_printy, to_printx;
     register float value0, value1, value2;
     const long NRARE = 5;
   
     
     // Print the first, last, and every NRARE-th layer:
     if(ldiv(z, NRARE).rem==0 || z==0 || z==X0.N4()-1 || z==X0.N4()-2) to_printz=1; else to_printz=0;
    
     if(to_printz) printf("\n----- z = %3ld -----\n", z);
     
     float fz_accu=0,  fy_accu=0.0,  fx_accu = 0.0;
     
     for (long y=0; y<X0.N3(); y++) 
     for (long x=0; x<X0.N2(); x++)
      {
       value0 = X0.value(0, x, y, z); // Fx
       value1 = X0.value(1, x, y, z); // Fy
       value2 = X0.value(2, x, y, z); // Fz

       fx_accu += value0;  fy_accu += value1;  fz_accu += value2; 
       
       if(ldiv(y, NRARE).rem==0 || y==0 || y==X0.N3()-1) to_printy=1; else to_printy=0;
       if(ldiv(x, NRARE).rem==0 || x==0 || x==X0.N2()-1) to_printx=1; else to_printx=0;
       
       /*
       if(to_printx && to_printy && to_printz)
         printf("x=%3ld y=%3ld  f= (%+13.6e  %+13.6e  %+13.6e)\n", 
                 x,    y,           value0, value1, value2);
       */
      }                       // End of x,y loop
  
  
     if(to_printz) 
      {
       printf("In layer z = %3ld:  fx_accu= %+14.7e fy_accu= %+14.7e fz_accu= %+14.7e\n", 
	                z,         fx_accu,         fy_accu,         fz_accu); 
      }
    }                         // End of z loop 
   }                          // End of outputting the force map
   

   
   
   
   
   
   
   
   
  if (PF.getString("ENERGY MAP")=="yes") 
   {
    FBTimer::startTimer("output_energy_map");
    QString fname=base_fname+".energy.mda";
    printf("Writing %s...\n",fname.toAscii().data());
    FBSparseArray4D X0;
    FBTimer::startTimer("get_energy");
    Solver.getEnergy(X0);
    FBTimer::stopTimer("get_energy");
    write_mda(X0,fname);
    FBTimer::stopTimer("output_energy_map");
    
    // ----- Printing energies, rarefied -----
    for (long z=0; z<X0.N4(); z++) 
    {  
     bool to_printz, to_printy, to_printx;
     register float value;
     const long NRARE = 20;

     
     // Print the first, last, and every NRARE-th layer:
     if(ldiv(z, NRARE).rem==0 || z==0 || z==X0.N4()-1 || z==X0.N4()-2) to_printz=1; else to_printz=0;    
     if(to_printz) printf("\n----- z = %3ld -----\n", z);
          
     for (long y=0; y<X0.N3(); y++) 
     for (long x=0; x<X0.N2(); x++)
      {
       value = X0.value(0, x, y, z); // Energy in voxel
       
       if(ldiv(y, NRARE).rem==0 || y==0 || y==X0.N3()-1) to_printy=1; else to_printy=0;
       if(ldiv(x, NRARE).rem==0 || x==0 || x==X0.N2()-1) to_printx=1; else to_printx=0;
       
       if(to_printx && to_printy)
         printf("x=%3ld y=%3ld  E= %+13.6e\n",  x, y, value);
      }                       // End of x,y loop
    }                         // End of z loop 
    
   }                                   // End of outputting the energy map

   
  if (PF.getString("TRACK LOG")=="yes") 
   {
    FBTimer::startTimer("output_track_log");
    QString fname=base_fname+".tracklog.txt";
    printf("Writing %s...\n",fname.toAscii().data());
    FBErrorEstimator *EE=Solver.errorEstimator();
    QString txt=QString("Iteration\tEst.Rel.Err.\tsigma_11\tsigma_22\tsigma_33\tsigma_12\tsigma_13\tsigma_23\n");
    for (int it=0; it<Solver.getNumIterations(); it++) 
     {
       QList<double> tmp=EE->stressData(it);
       txt+=QString("%1\t%2\t%3\t%4\t%5\t%6\t%7\t%8\n")
       .arg(it).arg(EE->estimatedRelativeError(it))
       .arg(tmp.value(0)).arg(tmp.value(1)).arg(tmp.value(2))
       .arg(tmp.value(3)).arg(tmp.value(4)).arg(tmp.value(5));
     }
    write_text_file(fname,txt);
    FBTimer::stopTimer("output_track_log");
   }

   
  FBTimer::stopTimer("total");	
 
  if (PF.getString("TIMER LOG")=="yes") 
   {
    QString fname=base_fname+".timerlog.txt";
    printf("Writing %s...\n",fname.toAscii().data());
    QString txt;
    txt += QString("Iterations:\t%1\n").arg(Solver.getNumIterations());
    QStringList timer_names=FBTimer::timerNames();
    foreach (QString timer_name, timer_names) 
      { txt += QString("%1:\t%2\n").arg(timer_name).arg(FBTimer::elapsed(timer_name)); }
    write_text_file(fname, txt);
   }

  // Re-starting a test (one in series [1 .. NUM_TESTS]).
  
  // Modify BVF map only if more that one tests are run, and if 
  // this test (# tcounter) was not the last one:
  if (NUM_TESTS > 1  && tcounter < NUM_TESTS)
   {
    printf("tcounter = %3d Starting modifying of the BVF map.\n", tcounter);
    modify_bvf_map(bvfmap);
    Solver.setBVFMap(bvfmap);
     
    Solver.reset_after_solve();
   }            // End of modifying of the BVF map
   
 }           // End of   for(tcounter=1; tcounter<=NUM_TESTS; tcounter++)
 
 
 if(NUM_TESTS == 1) 
  {
   printf("===== Done 1 compression test in %s direction... =====\n", 
           dir.toAscii().data() );
  }
 else
 if(NUM_TESTS > 1) 
  {
   printf("===== Done %3d compression tests in %s direction... =====\n", 
           NUM_TESTS, dir.toAscii().data() );
  }
  else
  {
   printf("===== Wrong number of compression tests  =====\n");
   sleep(3);
  }
	 
}            // End of   if (PF.getString("COMPRESSION TEST")=="yes") 




return 0;
}














