/****************************************************************************
** Generated by HaiQ
**
** Project name:  fbblock
** Project date:  Tue Nov 16 2010
** Author: 
****************************************************************************/
#include <QApplication>
#include <QWidget>
#include <QDebug>
#include "fbtimer.h"

#include "arrays.h"
#include <math.h>
#include "mda_io.h"

#include <QFileInfo>
#include <QTime>
#include <QFile>

#include "fbblocksolver.h"
#include "fbblock.h"
#include "fbparameterfile.h"

void usage() {
	printf("Usage: fbblock [bvf_map_file] [parameter file]\n");
}

///////////////////////////////// ** ////////////////////////////////////
int main(int argc, char *argv[])
{
	QCoreApplication app(argc, argv);
	
	FBTimer::startTimer("total");
	
	//Determine the input file names (bvf map and parameters files)
	QString bvfmap_fname;
	QString param_fname;
	QString base_fname;
	{
		for (int i=1; i<argc; i++) {
			QString param=argv[i];
			if (QFileInfo(param).suffix()=="mda") {
				bvfmap_fname=param;
			}
			else if (QFileInfo(param).suffix()=="fes") {
				param_fname=param;
			}
		}
		base_fname=QFileInfo(bvfmap_fname).path()+"/"+QFileInfo(bvfmap_fname).baseName();
		#ifdef WIN32
		bvfmap_fname.replace("/","\\");
		param_fname.replace("/","\\");
		base_fname.replace("/","\\");
		#endif
	}
	
	//Check to make sure these are non-empty		
	if ((bvfmap_fname.isEmpty())||(param_fname.isEmpty())) {
		usage(); //print usage information
		return -1;
	}
	
	
	//Initialize the solver with the BVF map, and clear the bvfmap to save memory
	FBTimer::startTimer("set_bvf");
	FBBlockSolver Solver;
	{
		FBArray3D<unsigned char> bvfmap;
		if (!read_mda(bvfmap,bvfmap_fname)) {
			printf("Error reading bvf map: %s.\n",bvfmap_fname.toAscii().data());
			return -1;
		}
		else {
			printf("BVF map found: %ldx%ldx%ld\n",bvfmap.N1(),bvfmap.N2(),bvfmap.N3());
		}
		Solver.setBVFMap(bvfmap);
		bvfmap.clear();
	}
	FBTimer::stopTimer("set_bvf");
	
	FBTimer::startTimer("read_parameters");
	//Read the parameters in the parameter file
	FBParameterFile PF;
	PF.read(param_fname);
	
	//RESOLUTION
	QList<fbreal> resolution=PF.getArray("RESOLUTION"); 
	if ((resolution.count()==3)&&(!resolution.contains(0))) {
		printf("Setting resolution = %gx%gx%g mm^3\n",resolution[0],resolution[1],resolution[2]);
		Solver.setResolution(resolution);
	}
	else {
		printf("Error: invalid resolution.\n");
		return -1;
	}
	
	//EPSILON
	if (PF.getReal("EPSILON")>0) {
		printf("Setting epsilon = %g\n",PF.getReal("EPSILON"));
		Solver.setEpsilon(PF.getReal("EPSILON"));
	}
	
	//MAX ITERATIONS
	//if (PF.getInteger("MAX ITERATIONS")>0) {
		printf("Setting max iterations = %d\n",PF.getInteger("MAX ITERATIONS"));
		Solver.setMaxIterations(PF.getInteger("MAX ITERATIONS"));
	//}
	
	//NUM THREADS
	if (PF.getInteger("NUM THREADS")>0) {
		printf("Setting num threads = %d\n",PF.getInteger("NUM THREADS"));
		Solver.setNumThreads(PF.getInteger("NUM THREADS"));
	}
	
	//PRECONDITIONER
	if (PF.getString("PRECONDITIONER")=="yes") {
		printf("Compute with preconditioner..\n");
		Solver.setUsePreconditioner(true);
	}
	else Solver.setUsePreconditioner(false);
	
	//Young's modulus, Poission ratio
	fbreal youngs_modulus=1, poissons_ratio=0.3F;
	if (PF.getReal("YOUNGS MODULUS")) youngs_modulus=PF.getReal("YOUNGS MODULUS");
	poissons_ratio=PF.getReal("POISSONS RATIO");	
	printf("Setting Young's modulus = %g\n",youngs_modulus);
	printf("Setting Poisson's ratio = %g\n",poissons_ratio);
	FBTimer::stopTimer("read_parameters");
	
	FBTimer::startTimer("computing_stiffness_matrix");
	{	
		FBArray2D <float> stiffness_matrix;
		stiffness_matrix.allocate(24,24);
		compute_stiffness_kernel(stiffness_matrix,youngs_modulus,poissons_ratio,resolution); 
		Solver.setStiffnessMatrix(stiffness_matrix);
	}
	FBMacroscopicStrain strain;
	strain.eps11=strain.eps22=strain.eps33=strain.eps12=strain.eps13=strain.eps23=0;
	for (int i=0; i<3; i++)
	for (int j=0; j<3; j++)
		strain.boundaryRestrictions[i][j]=false;
	FBTimer::stopTimer("computing_stiffness_matrix");
		
	//COMPRESSION TEST
	if (PF.getString("COMPRESSION TEST")=="yes") {
		QString dir=PF.getString("COMPRESSION DIRECTION");
		if (dir=="X") {
			strain.boundaryRestrictions[0][0]=true;
			strain.eps11=1;
		}
		else if (dir=="Y") {
			strain.boundaryRestrictions[1][1]=true;
			strain.eps22=1;
		}
		else if (dir=="Z") {
			strain.boundaryRestrictions[2][2]=true;
			strain.eps33=1;
		}
		else dir="UNDEFINED";
		if (PF.getString("RESTRICT ALL SURFACES")=="yes") {
			printf("Restricting all surfaces...\n");
			base_fname=base_fname+"."+dir+"0";
			for (int i=0; i<3; i++)
			for (int j=0; j<3; j++)
				strain.boundaryRestrictions[i][j]=true;
		}
		else {
			base_fname=base_fname+"."+dir;
		}	
		
		FBTimer::startTimer("set_fixed_variables");
		long num_elements=0;		
		num_elements=Solver.setFixedVariables(strain);
		printf("Number of elements: %ld\n",num_elements);
		FBTimer::stopTimer("set_fixed_variables");
		
		FBTimer::startTimer("set_initial_displacements");
		Solver.setInitialDisplacements(strain);
		FBTimer::stopTimer("set_initial_displacements");
		
		QString initial_displacements_fname=PF.getString("INITIAL DISPLACEMENTS");
		if (!initial_displacements_fname.isEmpty()) {
			FBSparseArray4D displacements0;
			if (!read_mda(displacements0,initial_displacements_fname)) {
				qWarning() << "Unable to open initial displacements array:" << initial_displacements_fname;
				exit(-1);
			}
			Solver.setInitialDisplacements(displacements0);
		}
		
		printf("Performing compression test in %s direction...\n",dir.toAscii().data());		
		Solver.solve();
		printf("Done.\n");
		
		FBTimer::startTimer("get_stress_after_solve");
		QList<double> sigma=Solver.getStress();
		FBTimer::stopTimer("get_stress_after_solve");
		
		printf("\n\n\n");
		{
			QString fname=base_fname+".output.txt";
			QString txt;
			fbreal result=0;
			if (dir=="X") result=sigma[0];
			else if (dir=="Y") result=sigma[1];
			else if (dir=="Z") result=sigma[2];
			txt+=QString("Results of compression test in %1 direction:\n").arg(dir);
			txt+=QString("%1\n\n").arg(result);
			txt+=QString("STRESS:\n");
			for (int j=0; j<6; j++)
				txt+=QString("%1\t").arg(sigma[j]);
			txt+="\n";
			
			txt+="\nNUM ITERATIONS:\n";
			txt+=QString("%1\n").arg(Solver.getNumIterations());
			txt+="\nNUM ELEMENTS:\n";
			txt+=QString("%1\n").arg(num_elements);
			qDebug()  << txt;
	
			txt+="\nPARAMETERS:\n";
			QStringList paramkeys=PF.keys();
			foreach (QString paramkey,paramkeys) 
				txt+=QString("%1=%2\n").arg(paramkey).arg(PF.getString(paramkey));
			
			write_text_file(fname,txt);
		}
			
		if (PF.getString("DISPLACEMENT MAP")=="yes") {
			FBTimer::startTimer("output_displacement_map");
			QString fname=base_fname+".displacement.mda";
			printf("Writing %s...\n",fname.toAscii().data());
			FBSparseArray4D X0;
			Solver.getDisplacements(X0);
			write_mda(X0,fname);
			FBTimer::stopTimer("output_displacement_map");
		}
		
		if (PF.getString("FORCE MAP")=="yes") {
			FBTimer::startTimer("output_force_map");
			QString fname=base_fname+".force.mda";
			printf("Writing %s...\n",fname.toAscii().data());
			FBSparseArray4D X0;
			Solver.getForces(X0);
			write_mda(X0,fname);
			FBTimer::stopTimer("output_force_map");
		}
		
		if (PF.getString("ENERGY MAP")=="yes") {
			FBTimer::startTimer("output_energy_map");
			QString fname=base_fname+".energy.mda";
			printf("Writing %s...\n",fname.toAscii().data());
			FBSparseArray4D X0;
			FBTimer::startTimer("get_energy");
			Solver.getEnergy(X0);
			FBTimer::stopTimer("get_energy");
			write_mda(X0,fname);
			FBTimer::stopTimer("output_energy_map");
		}
		
		if (PF.getString("TRACK LOG")=="yes") {
			FBTimer::startTimer("output_track_log");
			QString fname=base_fname+".tracklog.txt";
			printf("Writing %s...\n",fname.toAscii().data());
			FBErrorEstimator *EE=Solver.errorEstimator();
			QString txt=QString("Iteration\tEst.Rel.Err.\tsigma_11\tsigma_22\tsigma_33\tsigma_12\tsigma_13\tsigma_23\n");
			for (int it=0; it<Solver.getNumIterations(); it++) {
				QList<double> tmp=EE->stressData(it);
				txt+=QString("%1\t%2\t%3\t%4\t%5\t%6\t%7\t%8\n")
						.arg(it).arg(EE->estimatedRelativeError(it))
						.arg(tmp.value(0)).arg(tmp.value(1)).arg(tmp.value(2))
						.arg(tmp.value(3)).arg(tmp.value(4)).arg(tmp.value(5));
			}
			write_text_file(fname,txt);
			FBTimer::stopTimer("output_track_log");
		}
	
		FBTimer::stopTimer("total");	
		if (PF.getString("TIMER LOG")=="yes") {
			QString fname=base_fname+".timerlog.txt";
			printf("Writing %s...\n",fname.toAscii().data());
			QString txt;
			txt+=QString("Iterations:\t%1\n").arg(Solver.getNumIterations());
			QStringList timer_names=FBTimer::timerNames();
			foreach (QString timer_name,timer_names) {
				txt+=QString("%1:\t%2\n").arg(timer_name).arg(FBTimer::elapsed(timer_name));
			}
			write_text_file(fname,txt);
		}
	}

	return 0;
}














